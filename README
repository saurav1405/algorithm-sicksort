# MSB-Based Bitwise Radix Sort (with Windowing)
This sorting algorithm leverages the binary representation of 32-bit unsigned integers to sort an array in linear time complexity per bit. The core idea is to sort the array bit by bit, starting from the most significant bit (MSB) to the least significant bit (LSB), i.e., from bit position 32 down to 1.

At each bit position k, the array is partitioned into windows—subarrays—based on previous bit-level divisions. Initially, the entire array is considered a single window. For each window, the elements are stably sorted based on the k-th bit (1-indexed from the MSB). This step effectively performs a stable binary radix sort over the bits.

For every sorting operation at a bit position k, the partition index (where elements with bit 0 end and bit 1 begin) is recorded. These indices define new sub-windows for the next iteration (bit k-1), ensuring previous sort orders are preserved.

A window is a contiguous subarray (range of consecutive indices) within the array. At every bit position k, the array is partitioned into one or more non-overlapping windows. The array maintains sorted order by higher (more significant) bits.
We sort only within each window, so that previously sorted bits are preserved and stability is maintained.
 Why Can We Sort Only Within Windows?
When sorting at a given bit position k, the sort must preserve the ordering established by previous (more significant) bits.

Since elements in different windows already differ in more significant bits, their relative positions should not be changed.

Therefore, we only sort within each window — the boundaries between windows are determined by earlier bit partitions.

Each sort step for a window uses a binary partitioning logic:
Traverse the window.
Move all elements with 0 in the k-th bit to the front.
Return the index p, which is the first index where a 1 appears at bit position k.



High-Level Steps:
Initialize a linked list of window boundaries with [0, n].

For each bit index from 32 down to 1:

For every window defined by consecutive nodes in the list:

Partition elements in that window based on the current bit.

Record the partition index if both 0 and 1 values are present.

Update the window list with this new boundary.

The array becomes fully sorted after processing all 32 bits.



Pseudocode
Function IterativeMSBRadixSort(arr: array of unsigned 32-bit integers):
    n = length(arr)
    windowList = new LinkedList()
    windowList.append(0)
    windowList.append(n)

    For bitIndex from 32 down to 1:
        node = windowList.head

        While node and node.next:
            start = node.value
            end = node.next.value - 1

            partitionIndex = PartitionByBit(arr, start, end, bitIndex)

            // Only insert new window if both 0s and 1s exist in this window
            If start <= partitionIndex <= end:
                node.insertAfter(partitionIndex)

            node = node.next.next if node.next else null


Function PartitionByBit(arr: array, start: int, end: int, bitIndex: int) -> int:
    p = start - 1
    For i from start to end:
        bitVal = GetBit(arr[i], bitIndex)
        If bitVal == 0:
            p = p + 1
            Swap arr[i], arr[p]
    Return p + 1


Function GetBit(number: int, bitIndex: int) -> int:
    // Bit positions are 1-based from MSB to LSB (32 to 1)
    Return (number >> (32 - bitIndex)) & 1


Class ListNode:
    value: int
    next: ListNode

    Method insertAfter(val: int):
        newNode = new ListNode(val)
        newNode.next = this.next
        this.next = newNode


Class LinkedList:
    head: ListNode

    Method append(val: int):
        if head is null:
            head = new ListNode(val)
        else:
            node = head
            while node.next:
                node = node.next
            node.next = new ListNode(val)


Why This Works:
Bitwise partitioning from MSB to LSB ensures correct order.

Windows are consecutive and non-overlapping, so we avoid mixing elements that differ in more significant bits.

Sorting within each window maintains previous orderings, providing a stable and correct sort.

Time complexity remains O(n) due to a constant number (32) of passes.

Time Complexity : O(n) for 32-bit integers
Space Complexity : O(n) for window list
In-Place : Yes
Stable  Yes

  
